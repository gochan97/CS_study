<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CS Study</title>
</head>
<body>
디자인 패턴과 프로그래밍 패러다임

디자인 패턴이란?

여러 사람들이 협업해서 코드를 작성 할 때, 다른 사람이 만든 코드를 이해하기는 쉽지 않다. 그런 코드를 수정하고 새로운 기능을 추가해야 하는데 그럴 경우 의도치 않은 오류가 발생 할 수 있다.
그럴 때 디자인 패턴이 의사소통의 일환으로 이런 문제를 해결해 준다.

패턴은 생성 패턴, 구조 패턴, 행위 패턴 3가지가 있다.

생성 패턴
    - 추상 팩토리: 서로 관련이 있는 객체들을 통째로 묶어서 팩토리 클래스로 만들고, 이를 팩토리 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴

    - 팩토리 메소드: 객체를 만들어 반환하는 함수를 제공하여 초기화 과정을 외부에서 보지 못하게 숨기고 반환 타입을 제어하는 방법

    - 빌더: 인스턴스를 생성자를 통해 직접 생성하지 않고, 빌더라는 내부 클래스를 통해 간접적으로 생성하는 패턴

    - 프로토 타입: 원본 객체를 새로운 객체에 복사하여 필요에 따라 수정하는 매커니즘

    - 싱글톤: 클래스의 객체를 하나만 만들어야 하는 경우 사용한다. 클래스 내에 인스턴트가 하나임으로 바로 꺼내 볼수 있고 메모리 낭비를 최소하 한다. (반드시 private 등의 접근 제한자를 통해 제한 해야한다.)

구조 패턴
    - 어댑터: 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 패턴

    - 브리지: 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조로 나눈 후 독립적으로 개발할 수 있도록 하는 구조

    - 컴포지트: 객체들을 트리 구조로 구성한 후, 구조들과 개별 객체들처럼 작업할 수 있도록 하는 구조 패턴

    - 데코레이터: 객체들을 새로운 행동들을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 객체들에 연결 시키는 구조적 디자인 패턴

    - 퍼사드: 라이브러리, 프레임워크, 또 다른 클래스들의 복잡한 집합에 대한 단순화된 인터페이스를 제공하는 패턴

    - 플라이웨이트: 각 객체에 모든 데이터를 유지하는 대신 여러 객체들 간에 상태의 공통 부분들을 공유하여 사용할 수 있는 RAM에 더 많은 객체들을 포함할 수 있도록 하는 패턴

    - 프록시: 원래 객체에 대한 접근을 제어하고, 원래 요구한 요청이 객체 도착하기 전에 또 다른 무언가를 수행할 수 있도록 하는 패턴

행위 패턴
    - 책임 연쇄: 핸들러들의 페인을 따라 요청을 전달할 수 있게 해주는 행동 패턴

    - 커맨드 : 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환하고 메서드드를 인수화, 요청의 실행 지연, 대기열, 실행 취 작업을 지원하는 패턴

    - 반복자 : 컬렉션의 요소들의 기본 표현을 노출하지 않고 그들을 하나씩 순회할 수 있도록 하는 패턴

    - 중재자 : 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 통신을 함으로 객체 간의 혼란스러운 의존 관계를 줄일 수 있는 패턴

    - 메멘토 : 객체의 구현 세부 사항을 공개하지 않으면서 해당 객체의 이전 상태를 저장하고 복원할 수 있게 해주는 행동 디자인 패턴

    - 옵서버 : 여러 객체에 관찰 중인 객체에 발생하는 모든 이벤트에 대하여 알리는 구독 메커니즘을 정의할 수 있는 패턴

    - 상태 : 객체의 내부 상태가 변경될 때 객체가 클래스를 변경한 것처럼 보일 수 있는 패턴

    - 전략 : 알고리즌들의 패밀리를 정의하고, 각 패밀리를 별도의 클래스에 넣은 후 그들의 객체들을 상호교환할 수 있도록 하는 패턴

    - 템플릿 메서드 : 부모 클래스에서 알고림의 골격을 정의하지만, 해당 알고리즘의 구조를 변경하지 않고 자식 클래스들이 알고리즘의 특정 단계들을 오버라이드 할수 있도록 하는 패턴

    - 방문자 : 알고리즘들을 그들이 작동하는 객체들로부터 분리할 수 있도록 하는 행동 패턴
</body>
</html>